import { supabase } from "@/lib/supabaseClient";
import { normalizeTopicPair } from '../utils/normalizeInput.js';
import { safeString, safeVideoNormalize, videoDefaults } from '../utils/safeString.js';

export interface Video {
  id: string;
  searchTerm: string;
  learningGoal: string;
  title: string;
  url: string;
  summary: string;
  level: string;
  channel: string;
  thumbnail: string;
  created_at: string;
}

export interface Quiz {
  video_id: string;
  searchTerm: string;
  learningGoal: string;
  title: string;
  url: string;
  level: string;
  difficulty: string;
  question: string;
  answer: string;
  created_at: string;
}

export interface RequestedTopic {
  id: string;
  searchTerm: string;
  learningGoal: string;
  created_at: string;
}

/**
 * Fetch videos from Supabase filtered by search term and learning goal
 */
export async function getVideos(searchTerm: string, learningGoal: string): Promise<Video[]> {
  try {
    // Apply normalization to ensure consistent queries
    const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
    
    const { data, error } = await supabase
      .from('videos')
      .select('*')
      .eq('searchTerm', normalizedSearchTerm)
      .eq('learningGoal', normalizedLearningGoal)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Supabase error fetching videos:', error);
      
      // Check for schema mismatch errors
      if (error.message?.includes('column') && error.message?.includes('does not exist')) {
        throw new Error('Supabase query failed. Check that column names match the schema (searchTerm, learningGoal).');
      }
      
      throw new Error(`Failed to fetch videos: ${error.message}`);
    }

    // Apply safe normalization to all returned videos
    const safeVideos = (data || []).map(video => safeVideoNormalize(video));
    return safeVideos;
  } catch (error: any) {
    console.error('Error in getVideos:', error);
    throw error;
  }
}

/**
 * Fetch quizzes from Supabase filtered by search term and learning goal
 */
export async function getQuizzes(searchTerm: string, learningGoal: string): Promise<Quiz[]> {
  try {
    // Apply normalization to ensure consistent queries
    const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
    
    const { data, error } = await supabase
      .from('quizzes')
      .select('*')
      .eq('searchTerm', normalizedSearchTerm)
      .eq('learningGoal', normalizedLearningGoal)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Supabase error fetching quizzes:', error);
      
      // Check for schema mismatch errors
      if (error.message?.includes('column') && error.message?.includes('does not exist')) {
        throw new Error('Supabase query failed. Check that column names match the schema (searchTerm, learningGoal).');
      }
      
      throw new Error(`Failed to fetch quizzes: ${error.message}`);
    }

    // Apply safe normalization to all returned quizzes
    const safeQuizzes = (data || []).map(quiz => ({
      ...quiz,
      question: safeString(quiz?.question) || 'No question available',
      answer: safeString(quiz?.answer) || 'No answer available',
      difficulty: safeString(quiz?.difficulty) || videoDefaults.difficulty,
      title: safeString(quiz?.title) || videoDefaults.title,
      url: safeString(quiz?.url) || '',
      level: safeString(quiz?.level) || videoDefaults.level,
      searchTerm: safeString(quiz?.searchTerm) || videoDefaults.searchTerm,
      learningGoal: safeString(quiz?.learningGoal) || videoDefaults.learningGoal
    }));
    return safeQuizzes;
  } catch (error: any) {
    console.error('Error in getQuizzes:', error);
    throw error;
  }
}

/**
 * Request a new topic to be generated by adding it to requested_topics table
 */
export async function requestTopic(searchTerm: string, learningGoal: string): Promise<void> {
  // Apply normalization to ensure consistency
  const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
  
  const { error } = await supabase
    .from('requested_topics')
    .insert({
      searchTerm: normalizedSearchTerm,
      learningGoal: normalizedLearningGoal
    });

  if (error) {
    console.error('Error requesting topic:', error);
    throw new Error(`Failed to request topic: ${error.message}`);
  }
}

/* Standardized Supabase function fetch â€” replace existing function calls with this */
const SUPER_TASK_URL = "https://csrggvuucfyeaxdunrjy.supabase.co/functions/v1/super-task";

async function callSuperTask(payload: any) {
  const res = await fetch(SUPER_TASK_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNzcmdndnV1Y2Z5ZWF4ZHVucmp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc5NTE4ODAsImV4cCI6MjA3MzUyNzg4MH0.Vzt39Inny0ZvsNBICr47HL_lXnK67zFa4ekYO2fguGE",
    },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    const text = await res.text().catch(()=>null);
    throw new Error(`Super-task failed: ${res.status} ${res.statusText} ${text || ''}` );
  }
  return res.json();
}

/**
 * Dynamic learning path generation - calls the API endpoint
 */
export async function generateLearningPath(searchTerm: string, learningGoal: string): Promise<{
  status: 'exists' | 'started' | 'in_progress';
  videos?: Video[];
  message: string;
  log_id?: string;
  estimated_time?: string;
}> {
  try {
    const payload = {
      searchTerm: searchTerm.toLowerCase(),
      learningGoal: learningGoal.toLowerCase()
    };
    const response = await callSuperTask(payload);

    return response;
  } catch (error: any) {
    console.error('Error generating learning path:', error);
    throw new Error(`Failed to generate learning path: ${error.message}`);
  }
}

/**
 * Check generation status by polling the videos table
 */
export async function checkGenerationStatus(searchTerm: string, learningGoal: string): Promise<{
  completed: boolean;
  videos: Video[];
  count: number;
}> {
  try {
    const { data: videos, error } = await supabase
      .from('videos')
      .select('*')
      .eq('searchTerm', searchTerm.toLowerCase())
      .eq('learningGoal', learningGoal.toLowerCase())
      .order('rank', { ascending: true });

    if (error) {
      console.error('Error checking generation status:', error);
      return { completed: false, videos: [], count: 0 };
    }

    return {
      completed: videos.length > 0,
      videos: videos || [],
      count: videos?.length || 0
    };
  } catch (error: any) {
    console.error('Error in checkGenerationStatus:', error);
    return { completed: false, videos: [], count: 0 };
  }
}

/**
 * Get generation logs for monitoring
 */
export async function getGenerationLogs(searchTerm?: string, learningGoal?: string): Promise<any[]> {
  try {
    let query = supabase
      .from('generation_logs')
      .select('*')
      .order('started_at', { ascending: false })
      .limit(10);

    if (searchTerm && learningGoal) {
      // Apply normalization to ensure consistent queries
      const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
      query = query
        .eq('searchTerm', normalizedSearchTerm)
        .eq('learningGoal', normalizedLearningGoal);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching generation logs:', error);
      return [];
    }

    return data || [];
  } catch (error: any) {
    console.error('Error in getGenerationLogs:', error);
    return [];
  }
}

/**
 * Check if a topic has already been requested
 */
export async function isTopicRequested(searchTerm: string, learningGoal: string): Promise<boolean> {
  // Apply normalization to ensure consistent queries
  const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
  
  const { data, error } = await supabase
    .from('requested_topics')
    .select('id')
    .eq('searchTerm', normalizedSearchTerm)
    .eq('learningGoal', normalizedLearningGoal)
    .limit(1);

  if (error) {
    console.error('Error checking requested topic:', error);
    return false;
  }

  return (data?.length || 0) > 0;
}

/**
 * Get all requested topics (for GitHub Actions processing)
 */
export async function getRequestedTopics(): Promise<RequestedTopic[]> {
  const { data, error } = await supabase
    .from('requested_topics')
    .select('*')
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching requested topics:', error);
    throw new Error(`Failed to fetch requested topics: ${error.message}`);
  }

  return data || [];
}

/**
 * Remove processed topics from requested_topics table
 */
export async function removeRequestedTopic(id: string): Promise<void> {
  const { error } = await supabase
    .from('requested_topics')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('Error removing requested topic:', error);
    throw new Error(`Failed to remove requested topic: ${error.message}`);
  }
}

/**
 * Mark video as completed in user_progress table
 */
export async function markVideoCompleted(userId: string, videoId: string): Promise<void> {
  try {
    const { error } = await supabase
      .from('user_progress')
      .upsert({
        user_id: userId,
        video_id: videoId,
        completed: true,
        completed_at: new Date().toISOString()
      }, {
        onConflict: 'user_id,video_id'
      });

    if (error) {
      console.error('Supabase error marking video as completed:', error);
      throw new Error(`Failed to mark video as completed: ${error.message}`);
    }
  } catch (error: any) {
    console.error('Error in markVideoCompleted:', error);
    throw error;
  }
}

/**
 * Get quizzes for a specific video by URL, search term, and learning goal
 */
export async function getQuizzesByVideo(videoUrl: string, searchTerm?: string, learningGoal?: string): Promise<Quiz[]> {
  try {
    let query = supabase
      .from('quizzes')
      .select('*')
      .eq('url', videoUrl)
      .limit(6);

    if (searchTerm && learningGoal) {
      // Apply normalization to ensure consistent queries
      const { searchTerm: normalizedSearchTerm, learningGoal: normalizedLearningGoal } = normalizeTopicPair(searchTerm, learningGoal);
      query = query
        .eq('searchTerm', normalizedSearchTerm)
        .eq('learningGoal', normalizedLearningGoal);
    } else if (searchTerm) {
      query = query.eq('searchTerm', safeString(searchTerm));
    } else if (learningGoal) {
      query = query.eq('learningGoal', safeString(learningGoal));
    }

    const { data, error } = await query.order('created_at', { ascending: false });

    if (error) {
      console.error('Supabase error fetching quizzes by video:', error);
      
      // Check for schema mismatch errors
      if (error.message?.includes('column') && error.message?.includes('does not exist')) {
        throw new Error('Supabase query failed. Check that column names match the schema (searchTerm, learningGoal).');
      }
      
      throw new Error(`Failed to fetch quizzes: ${error.message}`);
    }

    // Apply safe normalization to all returned quizzes
    const safeQuizzes = (data || []).map(quiz => ({
      ...quiz,
      question: safeString(quiz?.question) || 'No question available',
      answer: safeString(quiz?.answer) || 'No answer available',
      difficulty: safeString(quiz?.difficulty) || videoDefaults.difficulty,
      title: safeString(quiz?.title) || videoDefaults.title,
      url: safeString(quiz?.url) || '',
      level: safeString(quiz?.level) || videoDefaults.level
    }));
    return safeQuizzes;
  } catch (error: any) {
    console.error('Error in getQuizzesByVideo:', error);
    throw error;
  }
}

/**
 * Check if a video is completed by the user
 */
export async function isVideoCompleted(userId: string, videoId: string): Promise<boolean> {
  try {
    const { data, error } = await supabase
      .from('user_progress')
      .select('completed')
      .eq('user_id', userId)
      .eq('video_id', videoId)
      .eq('completed', true)
      .limit(1);

    if (error) {
      console.error('Supabase error checking video completion:', error);
      return false;
    }

    return (data?.length || 0) > 0;
  } catch (error: any) {
    console.error('Error in isVideoCompleted:', error);
    return false;
  }
}
